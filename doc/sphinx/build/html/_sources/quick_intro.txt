.. _quick-intro:


.. currentmodule:: mwavepy.network

*******************
Quick Introduction
*********************

This quick intro of basic mwavepy usage. It is aimed at those who are familiar with python, or are impatient. If you want a slower introduction, see the :doc:`slow_intro`.

Create Network from Touchstone Files
-------------------------------------

First, import mwavepy and name it something short, like ''mv''::

	import mwavepy as mv

If this produces an error, please see :doc:`installation`. The most fundamental object mwavepy is a n-port :class:`Network`. Commonly, a :class:`Network` is constructed from data stored in a touchstone files, like so.::
	
	>>> short = mv.Network('short.s1p')
	>>> delay_short = mv.Network('delay_short.s1p')

Important Properties
+++++++++++++++++++++++++
	
The important qualities of a :class:`Network` are provided by the 
properties:

* :attr:`Network.s` : Scattering Parameter matrix. 
* :attr:`Network.frequency`  : Frequency Object. 
* :attr:`Network.z0`  : Characterisic Impedance matrix.

These properties are stored as numpy.ndarray's. If you are using 
Ipython, then all properties and methods of a class, can be 
'tabbed' out. Methods of the :class:`Network` class provide
convenient ways to plot components of the s-parameters, below is a 
non-exhaustive list of common plotting commands,

* :func:`Network.plot_s_db` : plot magnitude of s-parameters in log scale
* :func:`Network.plot_s_deg` : plot phase of s-parameters in degrees
* :func:`Network.plot_s_smith` : plot complex s-parameters on Smith Chart

For example, to create a 2-port :class:`Network` from a touchstone file,
and then plot all s-parameters on the Smith Chart.

.. plot:: ./pyplots/quick_intro/simple_plot.py
   :include-source:

For more info about plotting see :doc:`examples/basic_plotting`.   


Element-wise Operations (Linear)
++++++++++++++++++++++++++++++++
	
Simple element-wise mathematical operations on the scattering parameter matrices are accessible through overloaded operators::

	>>> short + delay_short
	>>> short - delay_short 
	>>> short / delay_short 
	>>> short * delay_short

These have various uses. For example, the difference operation returns a network that represents the complex distance between two networks. This can be used to calculate the euclidean norm between two networks like ::
	
	(short- delay_short).s_mag

or you can plot it::

	(short - delay_short).plot_s_mag()

Another use is calculating or plotting de-trended phase using the division operator. This can be done by::
	
	detrended_phase = (delay_short/short).s_deg
	(delay_short/short).plot_s_deg()
	
	
Cascading and Embeding Operations (Non-linear)
++++++++++++++++++++++++++++++++++++++++++++++++
Cascading and de-embeding 2-port Networks is done so frequently, that it can also be done though operators. The cascade function is called by the power operator,  ``**``, and the de-embed function is done by cascading the inverse of a network, which is implemented by the property ``inv``. Given the following Networks::

	cable = mv.Network('cable.s2p')
	dut = mv.Network('dut.s1p')
	
Perhaps we want to calculate a new network which is the cascaded connection of the two individual Networks *cable* and *dut*::
	
	cable_and_dut = cable ** dut

or maybe we want to de-embed the *cable* from *cable_and_dut*::

	dut = cable.inv ** cable_and_dut

You can check my functions for consistency using the equality operator ::

	dut == cable.inv (cable ** dut)

if you want to de-embed from the other side you can use the flip() function provided by the Network class::

	dut ** (cable.inv).flip()

Sub Networks
++++++++++++++++++++++++++
Frequently, the individual responses of a higher order network are of interest. Network type provide way quick access like so::

	reflection_off_cable = cable.s11
	transmission_through_cable = cable.s21


Connecting Multi-ports 
+++++++++++++++++++++++++
**mwavepy** supports the connection of arbitrary ports of N-port networks. It does this using an algorithm call sub-network growth. This connection process takes into account port impedances.
Terminating one port of a ideal 3-way splitter can be done like so::

	tee = mv.Network('tee.s3p')
	delay_short = mv.Network('delay_short.s1p')

to connect port '1' of the tee, to port 0 of the delay short::

	terminated_tee = mv.connect(tee,1,delay_short,0)
